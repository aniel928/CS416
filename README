Anne Whitman : alh220
Michael Mazzola : mjm706

(I originally wrote this in word but you cant upload a .doc to bitbucket so if the format is weird that's why)

Quick Important Notes:
	Memory Size: 8 Megabytes
	Operating System Region Size: 1 Megabyte
	Shared Region Size: 4 Pages
	User Region Size: 7 Megabytes – 4 Pages
	Size of Swapfile: 16MB
	THREADEQ is set to 1
	LIBREQ is set to 0

	

Analysis
Tests:
-Mallocing and freeing 5mb 1000 times in a loop
-Mallocing 2MB 10 times and accessing the data in the first call after the last.
-Mallocing 10MB and trying to free it 1000 times in a loop
-Freeing without mallocing
-One malloc call for 6mb followed by a free and then 1000 malloc calls for 6000 bytes
-Allocating 5MB in 6 different threads
???


Methods Definitions, Descriptions, and Return Values

int findConsecutivePages(int numPages);
    This method is used to traverse the page table and search for a number of consecutive pages that are available to the current thread. 
    If a group of pages is found successfully, it will return the index of the pages. If the search is unsuccessful it will return -1.

int findSwapIndex();
    This method will search for the first index available in the swap file. If an index is found it will be returned. 
    If an index isn’t found, meaning there were no indices available, the method returns -1. 

int findEvictIndex(int numPages);
    This method will search the page table for an index that is eligible be evicted. 
    It is given an integer value ‘numPages’ which is used as a number of consecutive pages that are to be searched for and evicted if found. 
    If it finds the necessary amount of available consecutive pages it returns the index of the first, otherwise, -1 is returned. 

int evictPage(int page);
    This method is given an index in the page table that needs to be evicted to allow for its space to be used by a different malloc call. 
    It first searches the swap file for an available index using the findSwapIndex function, and, if an available index is located, copies the pages data to the swap file. 
    If an index was successfully located by the findSwapIndex function this method will return the found index, otherwise it will return -1.

** I think this may be worded wrong, I'm not sure if this funtion should always work? yk? cause if it needs to restore a page then the buffer comes into play etc..int restorePage(int page, int offset);
    This method is given a page and an offset. It first takes the given page and attempts to evict it using the evictPage function. 
    If the swap file is full and the page could not be evicted, the method will return -1. 
    If a page is found, the method then copies the data from the swap file into the previously evicted page in the page table and returns the index of the restored page. 

void segment_fault_handler(int signum, siginfo_t *si, void* unused);
    This method is automatically called when a segmentation fault occurs. 
    It determines if it was called due to a legitimate segmentation fault or if there needs to be a page swap. 
    If the segmentation fault was legitimate the program will exit, otherwise, 
    it will use the 'restorePages' method to retrieve the appropriate page from the swap file and continue compiling. 

**void mallocInit();
    This method is called the first time that malloc is called. 
    It first uses posix_memalign to align the memory array, then builds the swap file of size 16MB and sets all the bytes to zero. 
    Afterwards, it builds the struct for the segmentation fault handler. Lastly, it sets all the indices in the page table to -1. 

spaceBetween(metadata* curr, int size, int bytesFree);
    This method is used after an allocation request was granted by using pages that were previously freed. 
    If there are extra bytes leftover after the request is satisfied, a new metadata structure is appended to the end of the bytes for future reference. 

int combineFreeStuff(metaData* iter);
    This method is given a metadata structure and will check to see if the metadata following it in the memory buffer is free. 
    It first stores the given metadata bytes in a variable labeled ‘bytesFree’ and will continuously add the bytes of the following metadata’s 
    until it reaches one that is currently being used or is NULL. Once the search is complete, the method returns ‘bytesFree’.
	
**void* myallocate(int size, char* file, int line, int threadId);
    This method is used for memory allocation and replaces the malloc call. 
    A memory region is sectioned into three partitions, the operating system region, the user space region, and the shared memory region. 
    This method has access to both the operating system and user space section. It is given a requested size, a file and line for reference 
    of where the call originated, and a value of 0 or 1 to determine if the call is pertaining to an operating system or a user process. 
    If the value of the threadid is 0, the method will handle the call in the operating system region and will return a pointer to chunk of bytes 
    the size that was requested. The metadata for this chunk will be stored directly before the address that is being returned. 
    If the value of the threaded is 1, the method will handle the request by distributing bytes from the user space. 
    This region implements paging. When a request is made, the number of pages necessary is determined from the size given and an available location is searched for. 
    If the space is found it will return a pointer to this location with the metadata stored before it. If a page is not found, a page will be selected for eviction and its 
    data stored in a swap file. A page table is used to keep track of all the pages and their current status as well as assisting in other functions such as determining which 
    pages are eligible to be evicted. If the both the memory region and swap file are filled and there is no more allocation room, the method will return -1.

** void mydeallocate(void* ptr, char* file, int line, int threadid);
    This method is used to deallocate memory in the memory region. It first checks if the value given is NULL, and if so it will return. 
    It then checks the address of the given pointer to see which region in memory is being referenced. 
    If the pointer belonged to the operating system region it sets its in use value to zero and allows for future malloc calls to this region to utilize this space. 
    It then checks if the pointer points to an address in the shared region and if so it frees this address too. 
    Lastly, if the address exists in the user space region, it will check if the last page has more than one allocations 
    (by checking the counter in the page table), and if so it will decrement its count and set any other pages count to zero. 
    If there is only one allocation it will reset the count of all the pages to zero. It also sets the thread ID in the page table to -2 for memory protecting purposes. 
    It will then set the metadata that is associated with the pointer to no longer in use which will allow for future malloc calls to this region to have access to these bytes.
    If the address is pointing somewhere in the memory region but there is no metadata associated with it, the free call will fail, as it is an invalid address. 

** I’m for sure missing some stuff in this --void* shalloc(int size);
    This method is used to distribute memory in the shared memory region. 
    This region does not use paging and can be accessed from both the user and operating system. 
    It will return a pointer to the beginning of a chunk of data which size is equal to the size requested. 
    The metadata for this is stored directly in front of the address of the pointer. If there isn’t enough space to satisfy the request the function will return NULL.
